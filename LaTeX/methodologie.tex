%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{Methodologie}
\label{ch:methodologie}

%% TODO: Hoe ben je te werk gegaan? Verdeel je onderzoek in grote fasen, en
%% licht in elke fase toe welke stappen je gevolgd hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent. Je moet kunnen aantonen dat je de best
%% mogelijke manier toegepast hebt om een antwoord te vinden op de
%% onderzoeksvraag.

\section{Redenen van een omschakeling?}
\label{sec:methodologie-redenen-omschakeling}

Puppet is een CMT met vele mogelijkheden maar heeft als nadeel zijn complexe leercurve. Veel mensen waaronder ook \textcite{danAnsiblevsPuppet} en zijn collega's, \textcite{martinAnsiblevsPuppet} en \textcite{AliAnsiblevsPuppet} delen deze mening. Dit was ook het probleem bij de VRT. Dankzij de complexiteit waren er maar een beperkt aantal mensen die het volledige potentieel van Puppet wisten te benutten. Het vertrek van \'e\'en van deze experten was dan ook een jammere zaak.

Dit is echter niet het enige. Door het gebrek aan een deftig ingebouwde monitoringstool kost het veel werk om te controleren welke servers correct geconfigureerd zijn. Idealiter zou er  's ochtends gekeken worden welke servers groen en rood kleuren. Voorlopig gebeurt dit via de command line interface.  

Verder maakt de VRT, zoals vele bedrijven, gebruik van meerdere omgevingen. Zo bestaat er van veel servers een versie in development, staging en productie. Zo kunnen nieuwe configuraties eerst in de development omgeving uitgetest worden alvorens deze in productie te brengen. Puppet kent het verschil niet tussen deze omgevingen. Dit heeft tot gevolg dat Puppet nieuwe configuraties pusht naar elke server, ongeacht of deze productie-kritisch is of niet. Dit is vanzelfsprekend niet de bedoeling en om dit dan ook te voorkomen wordt er momenteel handmatig bepaald welke servers mogen updaten en niet. 

Puppet biedt voor veel van deze problemen een oplossing (denk maar aan Puppet dashboard). Doch, mochten veel van deze oplossingen ge\"integreerd willen worden dan zou dit echter leiden tot een  nieuwe refactor van de infrastructuur. Dit, terwijl een refactor in het verleden al tot twee maal toe gebeurd is. Het vertrek van de expert bemoeilijkt deze hele zaak en daarom is er besloten geweest om over te schakelen naar Ansible. 

Ansible biedt met Ansible Tower een ge\"integreede monitoringstool. Bovendien wordt Ansible door velen geprezen vanwege zijn eenvoud in syntax en configuratie. Zo heeft Ansible geen agent nodig om servers te configureren wat een enorm voordeel biedt. Er kan dus zonder iets te moeten installeren onmiddelijk overgegaan worden tot configureren. Ansible Tower kan met vele externe technologi\"en overweg wat de mogelijkheden tot continuous deployment vereenvoudigd. Zo is bijvoorbeeld git ingebouwd dewelke zorgt voor een eenvoudig beheer van de source code.

%TO DO - hoe eenvoudig ansible is om te leren
%- slechte monitoring
%- slecht geautomatiseert 
%- geen multi environment
%- expert vertrokken
%- gui veel werk en complex
%- oorspronkelijk geen modules, refactor, in feite nu weer refactor
%- updates zorgen voor compatiblieteistproblemen (denk ik)
%- puppet client niet ouder dan puppet master maar omgekeerd denkik wel (op te zoeken)

\section{Werking van Ansible en Puppet}
\label{sec:methodologie-technische-verschillen}

\subsection{Overzicht van Puppet en Ansible}



\begin{minipage}{15cm}
\begin{tabular}{ r |c c }
& \textbf{Ansible} & \textbf{Puppet} \\
  \hline	  		
\gls{programmeerparadigma}  & declaratief & declaratief  \\
\hline
Geschreven in & YAML & \gls{dsl}  \\
\hline
Gebasseerd op & Python & Ruby \\
\hline
Communicatieprotocol & SSH & HTTPS \\

\hline
  Push / Pull principe \footnote{Beide technologie\"en zijn in staat om zowel volgens push als pull methode te functioneren. Zo heeft ansible 'pull-mode' \autocite{ansiblePull} en \textcite{puppetkick} 'Puppet kick' } & \gls{push} & \gls{pull} \\
   \hline
   open poorten\footnote{Dit zijn de minimale vereisten van open poorten. Voor sommige features dienen meer poorten open te staan. Bijvoorbeeld 443 voor Ansible Tower of 8140 op elke Puppetclient voor de Puppet kick functionaliteit \autocite{puppetkick} }  & 22/tcp (client) & 8140/tcp (master)\\
  \end{tabular}
  \end{minipage}   

 Informatie opgehaald van \textcite{languagePuppet}, \textcite{masterproef}, \textcite{ansibledoc}



\subsection{Werking van Puppet}

Tussen de master en de client bestaat er een vertrouwensrelatie die onderhouden wordt door certificaten. Het is de Puppetmaster die verantwoordelijk is voor het verlenen van deze certificaten. Pas als deze in orde zijn kan Puppet  aan de configuraties van de clients beginnen. De verzameling van alle geschreven code wordt een manifest genoemd. Wanneer een Puppetagent wil controleren of hij nog up-to-date is, zal hij een catalogus aanvragen bij de Puppetmaster. Een dergelijke catalogus is in feite een manifest dat de Puppetmaster compileert. Deze catalogus is bovendien uniek voor elke Puppetagent. Dit komt omdat er bij het compileren van het manifest naar de catalogus rekening gehouden wordt met diverse parameters zoals de functie van de server of de distributie van het besturingssysteem dat op die server draait \autocite{Puppetlanguagecatalog}. Eens de Puppetagent zijn persoonlijke catalogus ontvangen heeft, zal deze voor zichzelf controleren of er verschillen zijn tussen zijn huidige configuratie en de staat die beschreven staat in de catalogus. Indien er afwijkingen zijn, worden deze ook automatisch opgelost \autocite{puppetdoc}.

\begin{figure}  \begin{center}
  \includegraphics[width=250px]{img/aanvraagCatalogus.png}
 \end{center}\caption{aanvraag van een catalogus bij de Puppetmaster door een Puppetclient. De Puppetagent is een deamon (stukje software) die op de Puppetclient draait.}  
  \label{fig:aanvraagCatalogus}
\end{figure}


\subsection{Werking van Ansible}

In tegenstelling tot Puppet maakt Ansible geen gebruik van agents. Dit betekent dat de Ansibleserver enkel de naam en het wachtwoord dient te kennen van de servers die hij moet configureren. Het authenticeren kan op verschillende manieren. Er wordt aangeraden om gebruik te maken van een SSH-key, wat het eenvoudigst is, maar ook andere middelen zoals een eenvoudig wachtwoord of het Kerberos-protocol worden ondersteund. De gewenste configuraties worden geschreven in playbooks met bijhorende Ansiblerollen. Eens een verbinding tot stand is gebracht, wordt het gecompileerde playbook naar de te configureren server gestruurd. Deze worden vervolgens op de clients uitgevoerd  en weer verwijderd. Ook Ansible bezit de functionaliteit om na te gaan of de huidige configuratie in lijn is met de ontvangen modules. Om servers te configureren met Ansible bestaan er bovendien twee manieren. Ansible playbooks kunnen in principe verstuurd worden naar de servers vanaf elke computer. Voor een grotere hoeveelheid servers is dit echter moeilijk onderhoudbaar en onoverzichtelijk. Hiervoor bestaat er de commerci\"ele versie waarbij de playbooks worden verstuurd vanaf een centraal punt. Dit centraal punt wordt Ansible Tower genoemd die een inventaris heeft van alle servers en playbooks die onder zijn verantwoordelijkheid vallen. Verschillende gebruikers kunnen vervolgens verschillende toegangsrechten krijgen zodat personen enkel servers kunnen configureren die onder hun bevoegdheid vallen \autocite{ansibledoc}.

%------------------------------------

\section{Technische analyse van Ansible en Puppet}
\label{sec:technischeanalyse}
\subsection{Opstelling van de testomgeving}
\label{sec:opstellingtestevn}
\subsubsection{Architectuur van de opstelling}

%\begin{wrapfigure}{R}{0.4\textwidth}
%	\centering
%	\includegraphics[width=0.4\textwidth]{img/infrastructruur.png}
%	\caption{\label{fig:infrastructuur} Server A, de master, configureert server B - D, de clients.}
%\end{wrapfigure}

\begin{wrapfigure}{R}{0.25\textwidth}
	\includegraphics[width=0.9\linewidth]{img/infrastructruur.png} 
	\caption{Infrastructuur}
	\label{fig:infrastructuur}
\end{wrapfigure}

%Vagrant is a tool for building and managing virtual machine environments in a single workflow

Deze opstelling is gerealiseerd door gebruik te maken van \textcite{whatisvagrant}. Dit is een tool die het mogelijk maakt om op eenvoudige wijze meerdere virtuele omgevingen op te zetten, te configureren en te beheren.  Voor elke omgeving bestaat is er een Vagrantbestand. Er is dus een Vagrantbestand voor de Ansibleinfrastructuur en \'e\'en voor de Puppetinfrastructuur. Voor elke van deze omgevingen wordt eerst de master aangemaakt, gevolgd door X aantal clients. Vagrant zorgt ervoor dat elke client  verbonden wordt met New Relic. Dit is de gekozen tool om de servers te monitoren. In het geval van Puppet wordt hierbij ook nog de Puppetagent ge\"installeerd. Elke client, zowel in de Ansible- als de Puppetinfrastructuur, is gebaseerd op dezelfde basebox en krijgt dezelfde resources toegekend. De masters beschikten over meer resources.

\fbox{\begin{minipage}{15em}
\textbf{Technische specificaties clients}\newline
Basebox: bertvv/centos72\newline
Aantal CPU's: 1\newline
Geheugen: 500 MB
\end{minipage}}

\subsubsection{Modus operandi}

Elke server wordt dus opgezet door middel van Vagrant. De situatie vlak nadat Vagrant de servers opgezet heeft, wordt hierna de 'beginstand' genoemd.
Vanuit deze situatie beginnen de CMT's de configuraties. Afhankelijk van de test worden de resultaten afgelezen van ofwel de \gls{CMT} ofwel de monitoringstool. 
Elke test wordt 30 keer uitgevoerd. Telkens de test opnieuw wordt uitgevoerd wordt deze eerst terug naar de beginstand gebracht\footnote{Weliswaar is deze beginstand voor de testen van \gls{partialconfig} en geen configuratie anders.}.
Deze gegevens worden vervolgens afgelezen en in een tabel genoteerd. Deze ruwe data wordt achteraf opgeschoont\footnote{Zo worden gegevens die geen onderdeel meer uitmaakten van de test verwijderd of werd er gezorgd dat elke dataset even lang is. Belangrijk is te weten dat deze aanpassingen enkel gebeurt zijn waar mogelijk en dat deze geen negatieve invloed hebben op berekeningen en conclusies. } en kan teruggevonden worden in bijlage C, datasets. Achteraf is het op deze data dat de analyses en mathematische berekingen zijn gebeurd. De resultaten kunnen teruggevonden worden in onderstaande secties.

\subsubsection{Configuratie van servers door CMT's }


Voor de testen in sectie \ref{sec:technischeanalyse} is er gekozen om gebruik te maken van een LAMP-stack. Dit is zowel voor Ansible als Puppet gebeurd. Bovendien werd er getracht om in de mate van het mogelijke beide configuraties zo analoog mogelijk te houden. Om dit te realiseren wordt er httpd, php, php-mysql en mariaDB ge\"installeerd op de servers. Vervolgens wordt er een webpagina op de site geplaatst. Deze is geschreven in PHP en controleert of alle zaken naar behoren werken. Om af te sluiten wordt HTTP doorgelaten door de firewall, de service httpd gestart en MariaDB gestopt. 

Opmerking: De reden dat MariaDB op dit moment nog niet gestart wordt is vanwege de testen uitgevoerd voor de \gls{partialconfig}. Hierbij wordt gekeken hoelang het duurt om bij een bestaande configuratie enkele aanpassingen door te voeren. Het is dus pas bij de testen van \gls{partialconfig} dat MariaDB gestart wordt.


Deze configuraties kunnen teruggevonden worden op Github op de volgende links\footnote{Mogelijk komt beschreven configuratie in dit rapport niet volledig overeen met de code in de Github repositories. Deze repositories worden namelijk ook gebruikt voor andere testen  binnen dit onderzoek.}:\newline
\textbf{Ansible:} https://github.com/ThomasDetemmerman/AnsibleTower \newline
\textbf{Puppet:} https://github.com/ThomasDetemmerman/PuppetMaster



\subsection{Belasting van het netwerk}
Ansible en Puppet hebben een groot verschil in de manier van communiceren en dit weerspiegelt zich in het gedrag van de \gls{CMT}. De grafieken op afbeeldingen \ref{fig:netwerkverbruik} en \ref{fig:deploytypes} weerspiegelen uitsluitend het dataverkeer tussen de server (Ansible Tower of Puppetmaster) en de desbetreffende client. Andere data, zoals bijvoorbeeld het downloaden van services of uploaden van logbestanden naar de monitoringstool, zijn hierin \underline{niet} opgenomen. Dit wordt verwezenlijkt door gebruik te maken van verschillende netwerkkaarten. Wanneer er geen deploy gebeurt, is de kilobyte/ minuut op deze netwerkkaart gelijk aan nul; een bewijs dat hier geen andere data dan deze van de \gls{CMT} over wordt verstuurd.  
	
De manier van communicatie is te herkennen in de grafieken. Zo onderhoudt Ansible de communicatie met de client gedurende de deploy. Hiermee wordt bedoeld dat Ansible op de hoogte is van de laatste stand van zaken op de client. Wanneer een bepaalde taak voltooid is, wordt Ansibel Tower hier onmiddellijk van op de hoogte gebracht. Zoals te zien is op grafiek \ref{fig:deploytypes} is er geregeld communicatie tussen beide servers. Weliswaar is er enkel communicatie wanneer iets voltooid is; er is dus geen onnodige communicatie. Zo is ook te zien hoe op T5 de communicatie nul is. Ansible had voor die periode niets te melden\footnote{Hier betreft het de service MariaDB die wordt gedownload}. 

Deze manier van werken is handig tijdens het testen van nieuwe Ansible rollen. Je krijgt namelijk live feedback tijdens het uittesten. Een nadeel is wel dat het netwerk geen rust krijgt. Bovendien wordt deze functionaliteit van 'live feedback' enkel gebruikt voor testen. Eens een rol opperationeel is, lopen deze doorgaans tijdens de nacht en is het voldoende om de dag daarna een algemeen overzicht te krijgen. 

Bij Puppet is dit anders. Hierbij is er enkel communicatie tussen de server en de client bij het begin en op einde van de deploy.  Tijdens de eerste reeks vraagt de client een \gls{catalog} op bij de master. Vervolgens wordden eventuele \gls{puppetplugin}'s gesynchroniseerd en vraagt de master \gls{fact}'s op bij de client. Op basis van deze gegevens wordt uiteindelijk de verwachte \gls{catalog} verstuurd. Tijdens het configureren is er geen communicatie tussen beide servers. Op het einde wordt een rapport in JSON-formaat terug naar de master gekoppeld \autocite{neworkusage}.
 
Een nadeel aan het feit dat er enkel in het begin en op het einde communicatie is, is dat er op de master geen live feedback gevolgd kan worden. Dit kan echter wel opgelost worden door in te loggen op de client en hier de live feedback te volgen met behulp van het commando "\texttt{puppet agent -t}". Het wordt wel nog steeds pas op het einde van de deploy terug naar de master gestuurd.

Vervolgens is er ook gekeken naar de totale netwerkbelasting. Hiervoor is er per client een cumulatie genomen van de kilobytes/minuut gedurende de gehele deploy. Deze waarden zijn terug te vinden in grafiek \ref{fig:netwerkverbruik}. Hier heeft Ansible een gemiddelde van 5802,29 kilobytes/deploy. Dit terwijl Puppet gemiddeld 9464,32 kilobytes/deploy haalt. 

\textbf{We kunnen dus concluderen dat Ansible minder grote bestanden verstuurd over het netwerk door deze op te splitsen in meerdere kleine bestanden verspreidt over de hele deploy. Hierbij is wel een voorturende verbinding vereist tussen beide servers.  Puppet aan de andere kant weet de communicatie te beperken tot twee reeksen. Op het einde van de rit heeft Puppet wel meer bestanden uitgewisseld dan Ansible. }

\begin{figure}
	\includegraphics[width=\linewidth]{img/netwerkverbruik.png}
	\caption{Totaal verbruikte netwerkcapaciteit per client gedurende het deployen. Dit bevat enkel communicatie tussen master en client.}  
	\label{fig:netwerkverbruik}
\end{figure}


\begin{figure}
	\includegraphics[width=\linewidth]{img/deploytypes.png}
	\caption{Manier van communiceren. Aantal kilobytes per tijdseenheid op een netwerkkaart die uitsluitend bedoeld is voor communicatie met Ansible Tower / Puppetmaster. }  
	\label{fig:deploytypes}
\end{figure}
 %-------------------------------------------------- einde netwerk
 
\subsection{Tijd tot het bekomen van een consistente staat}

Het is interessant om te weten wat de verhouding is tussen de gemiddelde \gls{configuratietijd} van Ansible en Puppet. Om dit op een zo betrouwbaar mogelijke manier te kunnen verwezenlijken, zijn de configuraties van Ansible en Puppet zo analoog mogelijk gehouden zoals te lezen is in sectie \ref{sec:opstellingtestevn}. De tijd kan worden onderverdeeld in twee delen.\newline
Het eerste deel van de tijd zal de \gls{connectietijd} genoemd worden. Dit is de tijd die het kost alvorens er effectief overgegaan kan worden tot configureren. Hieronder vallen zaken zoals het verzamelen van de nodige configuraties en het verzamelen van server-speciefieke waarden (zoals bijvoorbeeld distributie) en het compileren van een catalogus of module. Bij Ansible kon deze tijd gewoon berekend worden op basis van de resultaten\footnote{connectietijd = totaal verstreken tijd -  \unexpanded{$ \sum  $} (tijd playbooks)}. Bij Puppet is dit echter niet mogelijk en bijgevolg zijn deze resultaten met de hand gemeten.\newline
 De tweede tijd is de \gls{configuratietijd}. Dit is de tijd die nodig is om de configuratie effectief uit te voeren. Beide waarden zijn gebaseerd op de feedback van de corresponderende \gls{CMT}.




\subsubsection{\gls{configuratietijd}}
\begin{figure}
  \includegraphics[width=\linewidth]{img/deploytime_fullconfig.png} 
  \caption{Tijd tot het bekomen van een consistente staat, vertrekkende van een 'lege' server.}  
  \label{fig:deploytime_fullconfig}
\end{figure}




Aangezien de resultaten van 'volledige configuratie' (zie bijlage C: deploytijden) geen eenduidig verschil tonen tussen beide \gls{CMT}'s is er met behulp van de Z-toets aangetoond of er al dan niet een statistisch verschil is. Deze berekingen kunnen teruggevonden worden in bijlage A: hypothese configuratietijd.

Hierbij blijkt dat Z buiten het kritisch gebied valt waardoor de nulhypotese verworpen kan worden. Bijgevolg wordt aangenomen dat beide gemiddelden niet tot dezelfde verzameling behoren. Er kan dus worden geconcludeerd dat wanneer er wordt vertrokken van een lege server, Ansible er gemiddeld langer over doet dan Puppet. Dit is in dit geval een verschil van gemiddeld 11,3 seconden. 

De verschillen worden echter nog groter wanneer de test gedaan wordt met een gedeeltelijke configuratie. Hiermee wordt bedoeld dat er vertrokken is van servers die reeds geconfigureerd zijn en er slechts enkele aanpassingen moeten doorgevoerd worden. Deze aanpassingen zijn een service starten en de inhoud van de webpagina veranderen. De resultaten lopen niet door elkaar waardoor een Z-toets niet echt nodig is. Ansible deed gemiddeld 19,10 seconden voor de deploy met een vrij grote variatie van 33,40 seconden. Puppet haalde maar een vrij consistente 3,10 seconden met een variatie van 0,35.

In laatste instantie is er gekeken naar de tijd die het zou kosten tot de \gls{CMT} vaststelt dat de server reeds volledig geconfigureerd is en dat er geen aanpassingen meer nodig zijn. Hierbij resulteert Ansible op een gemiddelde van 18 seconden met opnieuw een vrij grote variatie van 18,25 seconden. Ook hier doet Puppet het opnieuw beter waarbij hij minder dan een seconde nodig heeft om vast te stellen dan dat er geen aanpassingen nodig zijn. Uiteraard zijn al deze waarden afhankelijk van de configuratie maar ze geven wel een duidelijke indicatie van de verschillen tussen beide \gls{CMT}'s.

\begin{figure}
	\includegraphics[width=\linewidth]{img/overzichtgemiddeldeconfigtijd.png} 
	\caption{Gemiddelde configuratietijd in seconden.}  
	\label{fig:deploytime_fullconfig}
\end{figure}

\textbf{Opmerking:} De \gls{connectietijd} is niet meegerekend in deze metingen. Het omvat hier uitsluitend de \gls{configuratietijd}.

De reden dat Ansible trager is dan Puppet wordt gewijd aan de manier van communiceren. Puppet verstuurt namelijk een volledige configuratie bij de start. Ansible doet dit niet en verstuurt taak per taak. Hierdoor wordt de verbinding meerdere malen geinitialiseerd en opnieuw verbroken. Deze veronderstelling werd gestaafd door de volgende test:

\begin{addmargin}[2em]{0cm}
\underline{Hypothese A}: Ansible verstuurt taak per taak.\newline
\underline{Hypothese P}: Puppet verstuurt een gehele configuratie op het moment van initialisatie.

\underline{Test}: de verbinding wordt verbroken tijdens het configureren.

\underline{Verwachting A}: nadat de verbinding verbroken is wordt geen nieuw taak gestart.\newline
\underline{Verwachting P}: de configuratie gaat zonder problemen verder.

\underline{Resultaat A}: de configuratie valt stil. Opmerkelijk hierbij is dat niettemin de configuratie stilvalt, deze niet stopt. De master heeft namelijk niet door dat de verbinding verbroken is en veronderstelt dat de client eenvoudigweg nog bezig is met configuren. Als later de verbinding hersteld wordt, gaat de configuratie opnieuw verder.\newline
\underline{Resultaat P}: de configuratie gaat ongestoord verder.
\end{addmargin}

Er wordt dus per taak, en dus ook per connectie, een module overgebracht van de master naar de client. Deze bestanden zijn terug te vinden in \texttt{$\sim$/.ansible/tmp}. Hierin is duidelijk te zien hoe, tijdens een configuratie, er per taak een nieuwe module (geschreven in Python) verschijnt en vervolgens weer verdwijnt. Dit wordt in dit onderzoek gezien als \'e\'en van de grootste oorzaken waarom Ansible trager is.  \textcite{AnsibleTuning} herkend dit probleem en biedt hiervoor een alternatief aan, genaamd 'pipelinging'. Hierdoor zouder er minder SSH-verbindingen nodig zijn die modules moeten overzetten. Een nadeel hieraan is wel dat \texttt{requiretty} uitgezet moet worden wat  {\color{red} mogelijk tot een beveiligingsprobleem kan leiden}.

\subsubsection{Connectietijd}

De \gls{connectietijd} is de periode tussen het moment waarop de opdracht om te configureren gegeven wordt en het moment waarbij er effectief overgegaan kan worden tot configureren. Hieronder vallen zaken zoals het verzamelen van bepaalde gegevens, compileren en het overbrengen van de nodige bestanden. Dit fenomeen wordt in dit rapport de \gls{connectietijd} genoemd. Bij de resultaten van de connectietijd is geen duidelijk verschil op te merken. Bovendien liggen de gemiddelden zeer dicht bij elkaar. Om vast te stellen of er een significant verschil is, is er opnieuw gebruik gemaakt geweest van de Z toets. Deze berekingen kunnen teruggevonden worden in bijlage A, hypothese connectietijd. Z ligt hier echter in het aanvaardingsgebied waardoor de nulhypothese, die stelt dat beide gemiddelden gelijk zijn, kunnen aanvaarden. Er is bijgevolg geen statistisch verschil tussen beide waarden.
%\begin{figure}
%  \includegraphics[width=\linewidth]{img/connectiontime.png} 
 % \caption{Tijd tot het initialiseren van een deploy}  
 % \label{fig:connectiontime}
%\end{figure}

\textbf{Er kan hier dus geconcludeerd worden dat Ansible nood heeft aan een voortdurend goede verbinding tussen de master en de client om een snelle configuratie te kunnen verzekeren. Bij Puppet is dit niet zozeer nodig aangezien hierbij alle nodige bestanden voor een goede configuratie van meet af al aanwezig zijn. Vermoed wordt dat dit \'e\'en van de redenen is waarom Puppet sneller is in configureren.}

 {\color{red}Volgens deze link zou een reden zijn dat ansible trager is dan puppet omdat ze ssh gebruiken. te onderzoeken. http://www.intigua.com/blog/puppet-vs.-chef-vs.-ansible-vs.-saltstack}



%%---------------------------------------------------- einde performantie


\subsection{Gebruik van het geheugen}

Op grafiek \ref{fig:geheugengebruik} is per tijdseenheid het gemiddeld gebruikt ramgeheugen weergegeven. Hierop is te zien hoe Puppet opvallend meer geheugen gebruikt. Niet alleen tijdens een deploy maar ook ervoor en erna. Zelfs wanneer een Ansible client en een Puppet client juist opgezet worden met behulp van Vagrant, is er al een verschil in het gebruikte geheugen. Gezien het feit dat er al een verschil waar te nemen is in deze vroege levensfase van de server en het enige verschil in configuratie op dit moment de Puppetagent is, werd vermoed dat het verschil hier aan te wijten is. Dit vermoeden werd gestaafd toen de Puppetagent tijdelijk uitgezet werd. Het ramgeheugen daalde onmiddellijk naar gelijkwaardige waarden als deze van de Ansibleclient. Zonder configuratie gebruiken Puppetclients gemiddeld 58\% geheugen van de 500MB ram. Bij Ansible is dit 47\%. Dit betekent dat met een verschil van 11\%, er bij 500 MB 55MB meer RAM-geheugen gebruikt wordt bij Puppet.

\textbf{Er is dus een duidelijk verschil tussen het geheugengebruik van Puppet clients ten opzichte van Ansible clients. Hierbij gebruikt Puppet dankzij de Puppetagent beduidend meer resources. Ondanks het feit dat een service meer of minder doorgaans niet zorgt voor radicale gevolgen, is de grootste bottleneck nog steeds dat deze service in de eerste plaats ge\"installeerd en geconfigureerd dient te worden. Iets dat niet door Puppet verzorgd kan worden. Bij virtuele servers kan dit opgelost worden door gebruik te maken van een template.}

{\color{red} Hoe zet VRT  momenteel puppetagent op zijn puppetclients? > met template maar hoe bij fysieke server???}


\begin{figure}
  \includegraphics[width=\linewidth]{img/geheugengebruik}
 \caption{Verbruikt percentage van het RAM geheugen. Gemeten bij servers met elk 500 MB. }  
  \label{fig:geheugengebruik}
\end{figure}

%---------------------------------------------
\subsection{Schaalbaarheid}
\label{sec:schaalbaarheid}

Puppet kan minder servers  in parallel behandelen dan Ansible. Dit is ook niet nodig bij Puppet. Eens de Puppetmaster de \gls{catalog} gecompileerd heeft, neemt de Puppetagent die draait op de client het over. Dit is beduidend een kortere doorlooptijd dan Ansible. Aangezien Ansible geen gebruik maakt van deze agents valt niet enkel het compileren onder de verantwoordelijkheid van de master maar ook de uitvoering hiervan. Dit betekent dat Ansible zich over zijn clients moet ontfermen zolang deze hun gewenste consistente staat niet bereikt hebben.

Puppet heeft buiten de kortere doorlooptijd ook nog het principe van pull-mode dat in zijn voordeel werkt. Aanvragen voor \gls{catalog}sen gebeurt meer verspreid aangezien elke Puppetclient zelf verantwoordelijk is voor zijn updates. De kans dat veel servers tegelijk een aanvraag doen is vrij klein.  Bij Ansible worden vanwege de push-mode wel meerdere servers tegelijk behandeld. Het is dus vanzelfsprekend dan Ansible in staat moet zijn om meerdere configuraties in parallel te behandelen. 




 \subsubsection{Tips om de performantie van Ansible te verbeteren}
 
 Standaard is Ansible geconfigureerd om 5 servers tegelijk te kunnen configureren. Dit aantal kan toenemen door de parameter \texttt{\gls{fork}s} te verhogen naar 100 of zelfs meer. Dit zal inhouden dat Ansible 100 servers op hetzelfde moment kan configureren. Om dit te realiseren is Ansible afhankelijk van het RAM-geheugen. Hoe meer ramgeheugen er beschikbaar is, hoe hoger de paramter \texttt{\gls{fork}s} ge\"initialiseerd kunnen worden.
 
Ansible adviseert verder ook om gebruik te maken van \texttt{with\_items} bij het installeren van meerdere packages. Door het gebruik van \texttt{with\_items} zal Ansible deze packages combineren in \'e\'en transactieblok wat de performantie ten goede komt. Zo zou het dus beter zijn om listing \ref{lst:yamltwotask} te structuren zoals listing \ref{lst:yamlonetask}. 


   \lstset{language=clean,caption={Installeer de vereiste onderdelen van PHP in twee delen},label={lst:yamltwotask}}
\begin{lstlisting}[frame=single]

- name: installeer PHP
  package:
    name: php
    state: present

- name: installeer php-mysql
  package:
    name: php-mysqli
    state: present
\end{lstlisting}

  \lstset{language=clean,caption={Installeer de vereiste onderdelen van PHP in \'e\'en keer},label={lst:yamlonetask}}
\begin{lstlisting}[frame=single]
- name: installeer PHP en bijhorende extensies
  package:
    name: {{ item }}
    state: present
  with_items:
    - php
    - php-mysqli
\end{lstlisting}

  Verder beschikt Ansible over een 'Pull-mode' waarbij elke server zelf instaat voor zijn configuratie. Elke server haalt de code op van een centraal punt en configureerd vervolgens zichzelf. Deze manier van werken vereist wel een scriptje op elke server en doet denken aan de werking van Puppet. Een centraal management punt is in deze opstelling echter niet aanwezig en is dus af te raden voor grotere infrastructuren \autocite{AnsibleTuning} .
  
 \subsubsection{Tips om de performantie van Puppet te verbeteren}
 Puppet is door zijn manier van werken 'van nature' meer geloadbalanced dan Ansible. Toch zijn ook hier een paar zaken die de performantie ten goede komen. Het aantal aanvragen dat Puppet tegelijk kan behandelen is afhankelijk van het aantal cores aanwezig in de processor. Het aantal gebruikte cores staat gelijk aan het aantal aanvragen dat Puppet tegelijk kan behandelen. Wanneer er meer aanvragen zijn dan beschikbare cores zal het overschot aan aanvragen geblokkeerd worden tot er een core weer vrijkomt. Het aantal cores dat Puppet mag gebruiken kan handmatig ingesteld worden met behulp van de paramter \texttt{max-active-instances}. Wanneer deze naar bijvoorbeeld twee gebracht wordt, zullen twee cores van de processor gebruikt worden, wat tot gevolg heeft dat er ook twee aanvragen tegelijk behandeld kunnen worden. 
 
 Een tweede zaak is het verhogen van de \texttt{max heap size} van JVM. Door dit te verhogen kan het JVM proces meer geheugen opvragen bij het besturingssysteem \autocite{PuppetTuning}.
 
 \textbf{Ondanks het feit dat beide tools mogelijkheden bieden om de performantie te verhogen blijft Puppet beter geloadbalanced. Ansible zal dus sneller nood hebben aan een upgrade van de hardware dan Puppet. Een voordeel bij Ansible is dat het hoofdzakelijk het RAM geheugen is dat een upgrade vereist. Dit komt goedkoper uit dat een CPU met meerdere cores. }
 

 
 
 \section{Veiligheid}
 
 To Do, gesprek met mr. Gerben
 %---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------%
\section{Wat is het verloop van een dergelijke transitperiode?}
\label{sec:methodologie-verloop-transit}



\begin{wrapfigure}{R}{0.4\textwidth}
\centering
\includegraphics[width=0.4\textwidth]{img/vicieuzecirkel.PNG}
\caption{\label{fig:vicieuzecirkel}Vicieuze cirkel van twee \gls{CMT}'s hetzelfde bestand proberen te configureren.}
\end{wrapfigure}

Het is vanzelfsprekend dat de manier om Ansible te integreren afhankelijk is van bedrijf tot bedrijf. In het geval van de VRT verloopt dit vlot. \textbf{Ansible en Puppet kunnen namelijk perfect naast elkaar in dezelfde infrastructuur bestaan.} Dit is ideaal voor een geleidelijke overgang. E\'en en dezelfde server kan bovendien geconfigureert worden door zowel Puppet als Ansible. Dit heeft als voordeel dat niet alle modules geschreven in Puppet onmiddellijk vertaald hoeven te worden naar Ansible. Enkele rollen kunnen geschreven zijn voor Ansible terwijl een ander deel nog onder de bevoegdheid van Puppet valt.

 Belangrijk hierbij is wel dat Puppet en Ansible verschillende configuraties dienen te behandelen. Wanneer beide \gls{CMT}'s eenzelfde configuratie uitvoeren, kan er door subtiele verschillen een vicieuze cirkel ontstaan.
Veronderstel een situatie zoals in figuur \ref{fig:vicieuzecirkel}. In Ansible staat een bestand met een extra spatie, hier wordt deze voor het gemak 'foo1' genoemd. Bij puppet staat deze extra spatie er niet, deze wordt 'foo2' genoemd. 
\begin{enumerate}
\item Puppet configureert de service met bestand foo1 en start deze op.
\item  Eventjes later stelt Ansible vast dat de configuratie niet meer overeenkomt met deze beschreven in het playbook. Hij wijzigt foo1 naar foo2 en herstart de service zodat aanpassingen doorgevoerd zouden worden.
\item  Op een later ogenblik zal Puppet dit waarnemen en het bestand terugdraaien naar foo1, opnieuw gevolgd door een gerstart van de gerelateerde service.
\end{enumerate}
Het is vanzelfsprekend dat dit voor onnodige aanpassingen zorgt met eventueel ongewenste of onverwachte gevolgen, zoals het voortdurend herstarten van een service.

In de testopstelling is gekeken geweest naar het gedrag van beide \gls{CMT}'s wanneer deze op hetzelfde moment dezelfe server trachten te configureren. Dit veroorzaakte niet voor problemen.
Het enigste wat dit als nadelig gevolg kan hebben is dat de configuratie langer duurt dan normaal. Wanneer \gls{CMT} A een lock heeft op de \gls{packagemanager}, dan zal \gls{CMT} B moeten wachten tot deze vrij komt. 


%---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------        prijskaartje ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------%
 \section{Prijskaartje}

Ansible berekend de prijs op een lichtjes andere prijs dan Puppet. Bijgevolg hangt de prijs af van de situatie. Voor standaard enterprise support rekent Ansible 9.092,15 euro voor 100 nodes. Puppet berekend de prijst op het aantal gebruikte nodes. Dit is dan 109,12 euro per node. Bij 100 nodes komt Puppet dus duurder uit. Heb je echter minder als 100 nodes is Ansible duurder want je betaald standaard voor 100 nodes. Bij meerdere nodes dient een offerte aangevraagd te worden. Ook voor de premium editie dient voor beide technologie\"en een offerte aangevraagd te worden. \footnote{De valuta is geraadpleegd geweest op mei 2017 en zijn omgerekend van USD naar EUR tegen de wisselkoers op 5-5-2017}

